### 소스 코드
```java
class Solution {
    public int[][] solution(int[][] arr1, int[][] arr2) {
        int[][] answer = new int[arr1.length][arr2[0].length];

        for (int i = 0; i < arr1.length; i++) {
            for (int j = 0; j < arr2[0].length; j++) {
                int temp = 0;
                for (int k = 0; k < arr2.length; k++) {
                    temp += arr1[i][k] * arr2[k][j];
                }
                answer[i][j] = temp;
            }
        }
        
        return answer;
    }
}
```

### 왜 못 풀었는가?

행렬의 곱셈은 정말 오랜만에 만난다.. 행렬을 곱하는 공식이나 행렬을 곱할 수 있는 경우에 대해서 정확하게 생각이 나진 않았지만 하나 생각나는게 있어서 그걸로 기억을 더듬어 가면서 풀었다.

처음엔 손으로 풀면서 3x2 행렬 A와 2x2 행렬 B 가 주어졌을 때 두 행렬을 곱하면 A의 행 = 3 과 B의 열 =2 가 곱해서 나오는 행렬의 크키(?)가 된다는 건 알고 있었다.
즉, 결과로 나오는 행렬 C는 3x2 가 된다는 것. 

```
행렬 A (3 X 2) * (2 X 2) 행렬 B
A의 열과 B의 행이 2로 같기 때문에 곱하기를 할 수 있고 결과는 A의 행3 과 B의 열2를 가져와서
행렬 C (3 X 2) 가 된다.
```

문제에서는 곱하기를 할 수 있는 행렬만 주어진다고 제한사항에 명시되어 있기 때문에 곱하기를 어떻게 for 문으로 돌릴지 생각했다.

---

### 풀이

우선 결과로 만들어지는 행렬 C의 크기를 구해야 한다. 앞서 말했듯이 곱하기가 가능한 행렬만 주어지기 때문에 행렬 A의 행의 크기 `arr1.length`를, 행렬 B의 열의 크기 `arr2[0].length`를 가져와서 크기를 설정했다.

그리고 for문을 돌면서 행렬의 곱셈을 수행해야 했다.

첫 for 문인 `for (int i = 0; i < arr1.length; i++)`은 어렵지 않게 작성.

그리고 2차 배열이기 때문에 이중 for문을 사용해야 한다는 것까지 ok.   
그렇다면 2번째 for 문에는 조건을 어떻게 줘야하지..? 3x2 행렬이니까.... `for (int j = 0; j < arr1[0].length; j++)` 이 크기로 돌자!! (<- 이게 가장 큰 패착요인..)

근데 이대로 돌리면서 생각해보니까.. 아니지..??? 두 행렬을 곱해서 또 새로운 행렬에 값을 집어 넣어야 하니까... 2중으로는 안끝나고 3중으로 돌면서 새로 만들어지는 C에다가 A와 B를 돌면서 값을 넣어야 하지 않나..??

아!! 그렇다면 이 문제는 3중 for 문을 돌려야 하는구나!!! 

그렇게 3번째 for문을 만들기 시작.

자자... 생각을 해보자 그러면 이거는 앞에 두 for 문이 새로운 행렬에 집어넣은 인덱스를 가지고 있으니까.. 마지막 for 문은 행렬 A와 B를 적절히 돌려야 하는데이...
그렇게 손으로 필기 겁나 하면서 찾은 아래 코드.

```java
for (int k = 0; k < arr2.length; k++) {
    temp += arr1[i][k] * arr2[k][j];
}
```
손으로 곱셈을 계속 하면서 보니까 행과 열을 번갈아 가면서 곱하기 때문에 곱하는 와중에 01, 10 / 10 , 01 처럼 행렬의 순서가 바뀐다는 것을 알고 위의 코드를 작성했다.

자 그렇다면 코드를 돌려볼까??

---

### 처음 작성한 코드

```java
class Solution {
    public int[][] solution(int[][] arr1, int[][] arr2) {
        int[][] answer = new int[arr1.length][arr2[0].length];

        for (int i = 0; i < arr1.length; i++) {
            for (int j = 0; j < arr1[0].length; j++) {
                int temp = 0;
                for (int k = 0; k < arr2.length; k++) {
                    temp += arr1[i][k] * arr2[k][j];
                }
                answer[i][j] = temp;
            }
        }
        
        return answer;
    }
}
```

테스트는 훌륭하게 통과했다. 다만 제출했을때 모든 테스트 케이스가 실패 & 런타임 에러.... ㅇ..???????

뭔데 왜 실팬데!!!! 

하고 결국 다른 사람들의 풀이를 보게 되었다.. ㅠㅠ 

생각해보니 행렬A의 행 3 과 행렬 B의 열 2를 가져와서 행렬 C를 만들어 내는건데 위 코드에서 2번째 for 의 조건을 보게되면 A의 열을 가지고 오고 있다..!! 

(3x2)*(2x2) 에서 맨 앞 3과 맨 뒤2 를 가져와야 하는데 자꾸 앞 행렬의 2 를 가져오면서 뭔데 뭐 왜! 이러고 있었던 것... 테스트 케이스는 조건이 딱 맞아서 통과가 가능했기 때문에 놓쳤...다...

그러니까 `for (int j = 0; j < arr1[0].length; j++)` 이 부분을 `for (int j = 0; j < arr2[0].length; j++)` 이렇게... 아니 위에서 answer의 크기는 제대로 잡아놓고 왜 for는 엉뚱한 조건을 넣어서 돌렸냐고.. ㅠㅠ

덕분에 손으로 열심히 풀어서 구현하는 사이에 뇌정지 걸려서 이상하게 푼 문제가 되어버렸다.. ㅠㅠ

---

### 아쉽다..

접근은 다했는데 한걸음이 모자라서 문제를 내 힘으로 못 풀었다.. 사실 그래도 얼추 내가 찾았어!! 란 생각으로 푼 문제에다가 넣을까 했지만 그냥 못 푼 문제에다 넣기로 했다! for 문에 조건을 제대로 넣자!!
그래도 이렇게 정리하니까 어느 부분에서 놓쳤는지 알 수 있어서 좋았다. for문이 여러개 겹쳤을 때 조건을 더 제대로 볼 수 있는 힘을 기른 것 같다.

순서대로

1. 곱셈으로 만들어지는 행렬의 크기를 구한다.
2. 행렬의 크기대로 2중 for문을 돌린다.
3. 마지막 3번째 for 에서 행렬 B의 크기만큼 돌면서 곱셈 값을 찾는다. 끝
