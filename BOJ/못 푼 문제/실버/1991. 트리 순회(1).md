### 소스 코드

[문제 링크](https://www.acmicpc.net/problem/1991)

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
             BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))
        ) {
            int n = Integer.parseInt(br.readLine());

            Node rootNode = null;

            for (int i = 0; i < n; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                String root = st.nextToken();
                String left = st.nextToken();
                String right = st.nextToken();

                if (rootNode == null) {
                    rootNode = new Node(root);
                }

                insertNode(rootNode, root, left, right);
            }

            preOrder(rootNode);
            System.out.println();
            inOrder(rootNode);
            System.out.println();
            postOrder(rootNode);

            bw.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static void insertNode(Node rootNode, String root, String left, String right) {
        if (rootNode.data.equals(root)) {
            rootNode.addLeft(left);
            rootNode.addRight(right);
        } else {
            if (rootNode.left != null) {
                insertNode(rootNode.left, root, left, right);
            }
            if (rootNode.right != null) {
                insertNode(rootNode.right, root, left, right);
            }
        }
    }

    private static void preOrder(Node rootNode) {
        if (rootNode == null) {
            return;
        }
        System.out.print(rootNode.data);
        preOrder(rootNode.left);
        preOrder(rootNode.right);
    }

    private static void inOrder(Node rootNode) {
        if (rootNode == null) {
            return;
        }

        inOrder(rootNode.left);
        System.out.print(rootNode.data);
        inOrder(rootNode.right);
    }

    private static void postOrder(Node rootNode) {
        if (rootNode == null) {
            return;
        }

        postOrder(rootNode.left);
        postOrder(rootNode.right);
        System.out.print(rootNode.data);
    }

    public static class Node {
        String data;
        Node left;
        Node right;

        Node(String data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }

        public void addLeft(String data) {
            if (data.equals(".")) {
                return;
            }
            left = new Node(data);
        }

        public void addRight(String data) {
            if (data.equals(".")) {
                return;
            }
            right = new Node(data);
        }
    }
}
```

---

### 풀이 방법

오랜만에 알고리즘 문제를 다시 풀려고 하니... `Node` 를 작성한 것 까진 좋은데 `root`부터 시작해서 해당 노드를 찾아 다시 자식 노드를 설정하는 방법에서 막혔다..

전위/중위/후위 순회도 재귀로 탐색하는것까진 좋았으나 노드의 자식 노드 삽입이 안되니 확인할 수가...

나는 `Node` 안에 find 메서드를 만들어서 값이 넘어오면 해당 값을 가진 `node` 를 `return` 하려고 했는데 이렇게 하려고 보니 왼쪽을 먼저 싹 둘러보고 없으면 결과적으로 `return null` 을 하게 되서 오른쪽을 탐색하지 않고 끝나는게 문제였다 ㅠㅠ

찾은 방법에서는 별도의 `insertNode()` 라는 메서드를 만들어서 입력받은 데이터와 root노드를 가지고 삽입을 진행한다. 이렇게 보니 확실히 return 이 없기 때문에 왼쪽을 탐색 후 오른쪽을 탐색해서 올바른 위치에 값을 생성할 수 있었다...

그 이후에 순회 코드는 상당히 간단하기 때문에 쉽게 구현했다.

코드의 전체적인 흐름은 내가 생각한 그것이 맞는데.. 구현하는 과정에서 뭔가 제대로 작성하지 못했다. 한쪽을 다 탐색해서 없으면 다른쪽을 탐색한 후에 찾아와서 자식 노드를 집어넣어야 하는데 내가 작성한 코드는 
싹 탐색해서 없으면 null을 리턴하도록 구현했기 때문에 한쪽을 다 탐색하면 무조건 null을 리턴해서 다른 쪽을 탐색하지 못하는 것이 문제...

탐색 과정에서 찾아오지 않고 `insertNode()` 처럼 직접 들어가서 자식 노드를 설정하는게 중요하다! 

즉, 내가 구현한 방법은 탐색 -> 찾아오기(return node) -> 자식 노드 설정이고   
`insertNode()`는 탐색 -> 찾아서 바로 자식 노드 설정

과 같은 흐름이다. 

return 을 잘 못 사용해서 제대로 값을 찾을 수 없었던게 문제!! 바로 타고타고 들어가서 설정하는 방법이라는 뜻이다.

오랜만에 하니 Node 를 작성하는 것, 순회하는 방법 은 다 제대로 기억하고 있는데 값을 찾아서 넣는 방법을 기억하지 못해서 너무 수치스러웠다... ㅠㅠㅠ
